<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>WebTalk by DjCacho</title>
  <style>
    :root{color-scheme:dark light}
    body{font-family:system-ui,Arial,sans-serif;margin:16px}
    .card{border:1px solid #9993;border-radius:12px;padding:16px;max-width:820px;margin:0 auto}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    input,button{padding:10px;border-radius:10px;border:1px solid #8886}
    button{cursor:pointer}
    #peers{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:8px;margin-top:8px}
    .peer{border:1px solid #8884;border-radius:10px;padding:8px}
    audio{width:100%}
    .status{margin-top:8px}
    .dim{opacity:.7}
    .debug{font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#111; color:#ddd; padding:10px; border-radius:8px; margin-top:12px; white-space:pre-wrap}
    .debug .ok{color:#9f9}
    .debug .warn{color:#ff9}
    .debug .err{color:#f99}
  </style>
</head>
<body>
  <div class="card" id="loginCard">
    <h2>WebTalk</h2>
    <p>Introduce tu <b>nombre</b> y pulsa <b>Entrar</b>. Se habilitará el audio (requisito iOS).</p>
    <div class="row">
      <input id="nameInput" placeholder="Tu nombre" maxlength="64"/>
      <button id="enterBtn">Entrar</button>
    </div>
    <div class="status" id="loginStatus"></div>
  </div>

  <div class="card" id="roomCard" style="display:none">
    <h3>Sala global <span class="dim">(mic siempre abierto)</span></h3>
    <div class="row">
      <button id="muteBtn">Mic: ON</button>
      <button id="motoBtn">Modo Moto: OFF</button>
      <button id="leaveBtn">Salir</button>
      <label title="Fuerza TURN (relay) por 5349/TLS para probar redes móviles restrictivas" style="margin-left:auto">
        <input type="checkbox" id="turnOnly"/> Usar TURN-only (prueba)
      </label>
    </div>
    <div class="status" id="connStatus">Conectando…</div>

    <h4 style="margin-top:12px">Monitor local (opcional)</h4>
    <audio id="localMonitor" autoplay playsinline muted></audio>

    <h4>Participantes</h4>
    <div id="peers"></div>

    <div class="debug" id="debugBox" hidden></div>
  </div>

  <!-- Overlay Modo Moto -->
  <div id="motoOverlay" style="position:fixed; inset:0; background:#000; color:#fff; display:none; align-items:center; justify-content:center; flex-direction:column; z-index:9999;">
    <button id="overlayMute" style="font-size:22px; padding:14px 20px; border-radius:14px; border:1px solid #555; margin:8px 0; background:#111; color:#fff;">Mic: ON</button>
    <button id="overlayExit" style="font-size:22px; padding:14px 20px; border-radius:14px; border:1px solid #555; margin:8px 0; background:#111; color:#fff;">Salir de Modo Moto</button>
    <div class="hint" style="opacity:.6; margin-top:6px; font-size:14px">La pantalla se mantiene activa para no perder la comunicación.</div>
  </div>

<script>
(() => {
  const basePath = location.pathname.replace(/\/?$/, '');
  const WS_URL = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + basePath + '/ws';

  const loginCard = document.getElementById('loginCard');
  const roomCard  = document.getElementById('roomCard');
  const nameInput = document.getElementById('nameInput');
  const enterBtn  = document.getElementById('enterBtn');
  const loginStatus= document.getElementById('loginStatus');
  const connStatus = document.getElementById('connStatus');
  const muteBtn   = document.getElementById('muteBtn');
  const motoBtn   = document.getElementById('motoBtn');
  const leaveBtn  = document.getElementById('leaveBtn');
  const peersDiv  = document.getElementById('peers');
  const localMonitor = document.getElementById('localMonitor');
  const motoOverlay = document.getElementById('motoOverlay');
  const overlayMute = document.getElementById('overlayMute');
  const overlayExit = document.getElementById('overlayExit');
  const turnOnlyChk = document.getElementById('turnOnly');
  const debugBox = document.getElementById('debugBox');

  let ws=null, wsConnected=false, wsRetryTimer=null, pingTimer=null;
  let myId=null, myName='', joined=false;

  const pcMap=new Map();
  const streams=new Map();
  const peerNames=new Map();
  let localStream=null, micEnabled=true;

  const wf = new Map();
  const statsTimers = new Map();

  const ICE_STATIC = [
    { urls: ["stun:cachofotos.ddns.net:3478"] },
    { urls: ["turn:cachofotos.ddns.net:3478?transport=udp"], username: "djcacho", credential: "4+ymh5XaTXzAVkUB" },
    { urls: ["turn:cachofotos.ddns.net:3478?transport=tcp"], username: "djcacho", credential: "4+ymh5XaTXzAVkUB" },
    { urls: ["turns:cachofotos.ddns.net:5349"],              username: "djcacho", credential: "4+ymh5XaTXzAVkUB" },
    { urls: "stun:stun.l.google.com:19302" },
    { urls: "stun:stun.cloudflare.com:3478" }
  ];
  async function loadIceServers(){ return ICE_STATIC; }

  let ttsReady = false;
  async function initTTS(){
    try{
      try { speechSynthesis.cancel(); } catch(_) {}
      const waitVoices = new Promise(resolve => {
        const voices = speechSynthesis.getVoices();
        if (voices && voices.length) return resolve();
        speechSynthesis.addEventListener('voiceschanged', resolve, { once:true });
        setTimeout(resolve, 1500);
      });
      await waitVoices;
      const probe = new SpeechSynthesisUtterance('listo');
      probe.lang = 'es-ES'; probe.rate = 1.0; probe.volume = 0.01;
      speechSynthesis.speak(probe);
      ttsReady = true;
    } catch(_) { ttsReady = false; }
  }
  async function speakDebounced(text, key, ms=3000){
    const now=Date.now();
    speakDebounced.cache = speakDebounced.cache || new Map();
    const last = speakDebounced.cache.get(key) || 0;
    if (now - last < ms) return;
    speakDebounced.cache.set(key, now);
    try{
      if (!ttsReady) { await initTTS(); }
      const u=new SpeechSynthesisUtterance(text);
      u.lang='es-ES'; u.rate=1.0;
      speechSynthesis.speak(u);
    }catch(_){}
  }

  let wakeLock = null;
  async function enableWakeLock(){ try{ if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); }catch(e){} }
  async function disableWakeLock(){ try{ if (wakeLock) { await wakeLock.release(); wakeLock=null; } }catch(_){} }

  function connectedCount(){ return 1 + streams.size; }
  function niceName(pid){ return pid===myId ? `${myName} (tú)` : (peerNames.get(pid) || `ID: ${pid.slice(0,8)}…`); }
  function renderPeers(){
    peersDiv.innerHTML=''; connStatus.textContent = `Conectados: ${connectedCount()} | Tú: ${myName}`;
    for(const [pid, stream] of streams.entries()){
      const wrap=document.createElement('div'); wrap.className='peer';
      const title=document.createElement('div'); title.textContent = niceName(pid);
      const audio=document.createElement('audio'); audio.autoplay=true; audio.playsInline=true; audio.srcObject=stream;
      wrap.appendChild(title); wrap.appendChild(audio); peersDiv.appendChild(wrap);
    }
  }

  async function getMic(){
    return await navigator.mediaDevices.getUserMedia({
      audio:{ channelCount:1, echoCancellation:true, noiseSuppression:true, autoGainControl:true, sampleRate:16000, sampleSize:16 },
      video:false
    });
  }
  async function ensureLocalStream(){
    const needsNew = !localStream || localStream.getAudioTracks().length===0 || localStream.getAudioTracks().some(t => t.readyState==='ended');
    if (needsNew) { localStream = await getMic(); localMonitor.srcObject = localStream; }
    setMic(micEnabled);
  }
  function setMic(on){
    micEnabled=on; if(!localStream) return;
    localStream.getAudioTracks().forEach(t=>t.enabled=on);
    muteBtn.textContent = on ? 'Mic: ON' : 'Mic: OFF';
    overlayMute.textContent = on ? 'Mic: ON' : 'Mic: OFF';
    overlayMute.classList.toggle('muted', !on);
  }

  function startPing(){ stopPing(); pingTimer=setInterval(()=>{ try{ ws && ws.send(JSON.stringify({type:'ping'})); }catch(_){} }, 10000); }
  function stopPing(){ if(pingTimer){ clearInterval(pingTimer); pingTimer=null; } }
  function scheduleReconnect(){
    if(wsRetryTimer) return;
    wsRetryTimer = setInterval(()=>{ if(wsConnected || !joined){ clearInterval(wsRetryTimer); wsRetryTimer=null; return; } connectWS(); for(const [,pc] of pcMap) try{ pc.restartIce(); }catch(_){}} ,1500);
  }
  function connectWS(){
    try { ws && ws.close(); } catch(_){}
    ws=new WebSocket(WS_URL);
    ws.onopen=()=>{ wsConnected=true; startPing(); ws.send(JSON.stringify({type:'join', name: myName})); };
    ws.onclose=()=>{ wsConnected=false; stopPing(); scheduleReconnect(); };
    ws.onerror=()=>{ wsConnected=false; stopPing(); scheduleReconnect(); };
    ws.onmessage=async ev=>{
      const msg=JSON.parse(ev.data); const t=msg.type;
      if(t==='joined'){
        closeAll(); peerNames.clear(); myId = msg.clientId;
        try{ await ensureLocalStream(); }catch(e){ connStatus.textContent='Micrófono no disponible: '+e; return; }
        const peers=msg.peers||[]; for(const p of peers){ peerNames.set(p.clientId, p.name||'Usuario'); }
        renderPeers(); for(const p of peers){ await createPC(p.clientId); } return;
      }
      if(t==='peer-joined'){ peerNames.set(msg.clientId, msg.name || 'Usuario'); speakDebounced(`${msg.name || 'Usuario'} se ha conectado`, `join:${msg.clientId}`); if(!pcMap.has(msg.clientId)) await createPC(msg.clientId); renderPeers(); return; }
      if(t==='peer-left'){ speakDebounced(`${msg.name || 'Usuario'} se ha desconectado`, `left:${msg.clientId}`); closePC(msg.clientId); peerNames.delete(msg.clientId); renderPeers(); return; }
      if(t==='signal'){ const {fromId,payload}=msg; if(!pcMap.has(fromId)) await createPC(fromId); await handleSignal(fromId, payload); return; }
      if(t==='ice-restart'){ for(const [,pc] of pcMap) try{ pc.restartIce(); }catch(_){ } return; }
    };
  }

  async function handleSignal(peerId, payload){
    const pc = pcMap.get(peerId);
    const state = wf.get(peerId) || { makingOffer:false, ignoreOffer:false, isSettingRemoteAnswer:false };
    wf.set(peerId, state);
    try{
      if (payload.sdp) {
        const desc = payload.sdp;
        const offerCollision = (desc.type === "offer") && (state.makingOffer || pc.signalingState !== "stable");
        state.ignoreOffer = !isPolite(peerId) && offerCollision;
        if (state.ignoreOffer) return;
        if (desc.type === "answer") state.isSettingRemoteAnswer = true;
        await pc.setRemoteDescription(desc);
        state.isSettingRemoteAnswer = false;
        if (desc.type === "offer") {
          await ensureLocalStream();
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          wsSendSignal(peerId, { sdp: pc.localDescription });
        }
      } else if (payload.candidate) {
        try { await pc.addIceCandidate(payload.candidate); } catch (err) { if (!state.ignoreOffer) throw err; }
      }
    } catch (e) { try { await pc.setLocalDescription({ type:"rollback" }); } catch(_){ } }
  }
  function isPolite(peerId){ return myId > peerId; }
  function wsSendSignal(targetId, payload){ if (wsConnected) ws.send(JSON.stringify({ type:"signal", targetId, payload })); }

  async function createPC(peerId){
    if(pcMap.has(peerId)) return pcMap.get(peerId);
    const useTurnOnly = !!turnOnlyChk.checked;
    const iceServers = await loadIceServers();
    const pc=new RTCPeerConnection({ iceServers, iceTransportPolicy: useTurnOnly ? 'relay' : 'all' });
    pcMap.set(peerId, pc);
    wf.set(peerId, { makingOffer:false, ignoreOffer:false, isSettingRemoteAnswer:false });
    await ensureLocalStream();
    localStream.getTracks().forEach(tr=>pc.addTrack(tr, localStream));
    if (window.replaceMicWithNative) { try { window.replaceMicWithNative(pc); } catch (e) { console.warn('replaceMicWithNative error', e); } }
    const remoteStream=new MediaStream(); streams.set(peerId, remoteStream);
    pc.ontrack=(ev)=>{ ev.streams[0].getTracks().forEach(t=>remoteStream.addTrack(t)); renderPeers(); };
    pc.onicecandidate=(ev)=>{ if(ev.candidate) wsSendSignal(peerId, { candidate: ev.candidate }); };
    pc.onnegotiationneeded = async () => {
      const state = wf.get(peerId); if (!state) return;
      try { state.makingOffer = true; const offer = await pc.createOffer(); await pc.setLocalDescription(offer); wsSendSignal(peerId, { sdp: pc.localDescription }); }
      catch(_){} finally { state.makingOffer = false; }
    };
    pc.onconnectionstatechange=()=>{ diagUpdate(peerId); const s=pc.connectionState; if(s==='failed'||s==='disconnected'){ try{ pc.restartIce(); }catch(_){}}};
    const timer = setInterval(()=>diagUpdate(peerId), 3000); statsTimers.set(peerId, timer);
    renderPeers(); return pc;
  }

  function closePC(peerId){ const pc=pcMap.get(peerId); if(pc){ try{ pc.close(); }catch(_){}} pcMap.delete(peerId); streams.delete(peerId); wf.delete(peerId); const t = statsTimers.get(peerId); if (t){ clearInterval(t); statsTimers.delete(peerId); } diagUpdate(); }
  function closeAll(){ for (const pid of Array.from(pcMap.keys())) closePC(pid); }

  async function diagUpdate(peerId=null){
    if (!pcMap.size){ debugBox.hidden = true; return; }
    debugBox.hidden = false;
    let out = '';
    for (const [pid, pc] of pcMap.entries()){
      out += `Peer ${niceName(pid)}  |  conn=${pc.connectionState}  ice=${pc.iceConnectionState}\n`;
      try{
        const stats = await pc.getStats(); let sel=null;
        stats.forEach(r=>{ if (r.type === 'transport' && r.selectedCandidatePairId) sel = stats.get(r.selectedCandidatePairId); });
        if (!sel){ stats.forEach(r=>{ if (r.type==='candidate-pair' && r.nominated) sel = r; }); }
        if (sel){
          const local = stats.get(sel.localCandidateId);
          const remote = stats.get(sel.remoteCandidateId);
          out += `  ⇄ selected pair: local=${local?.candidateType}/${local?.protocol} ↔ remote=${remote?.candidateType}/${remote?.protocol} (${Math.round((sel.currentRoundTripTime||0)*1000)} ms RTT)\n`;
        } else { out += `  (no selected pair yet)\n`; }
      }catch(e){ out += `  stats error: ${e}\n`; }
      out += '\n';
    }
    debugBox.textContent = out.trim();
  }

  // ====== LOGGING AMPLIADO ======
  const log = (...args) => {
    console.log('[WebTalk]', ...args);
    const t = args.map(a => typeof a === 'object' ? JSON.stringify(a, null, 2) : a).join(' ');
    debugBox.hidden = false;
    debugBox.textContent = (debugBox.textContent + '\n' + t).split('\n').slice(-40).join('\n');
  };
  const oldWsSendSignal = wsSendSignal;
  wsSendSignal = function(targetId, payload){ log('📤 Señal enviada a', targetId, payload.sdp ? payload.sdp.type : payload.candidate ? 'ICE' : payload); oldWsSendSignal(targetId, payload); };
  const oldCreatePC = createPC;
  createPC = async function(peerId){ const pc = await oldCreatePC(peerId); log('🆕 RTCPeerConnection creada para', peerId); pc.addEventListener('iceconnectionstatechange', ()=>log('ICE', peerId, pc.iceConnectionState)); pc.addEventListener('connectionstatechange', ()=>log('CONN', peerId, pc.connectionState)); return pc; };
  // ============================================

  async function refreshMicAndRenegotiate(){
    if (!joined) return;
    try{
      await ensureLocalStream();
      for (const [pid, pc] of pcMap.entries()) {
        const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');
        const newTrack = localStream.getAudioTracks()[0];
        if (sender && newTrack && sender.track !== newTrack) { await sender.replaceTrack(newTrack); }
        try{ const state = wf.get(pid); if (!state) continue; state.makingOffer = true; const offer = await pc.createOffer({ iceRestart: true }); await pc.setLocalDescription(offer); wsSendSignal(pid, { sdp: pc.localDescription }); }finally{ const st2 = wf.get(pid); if (st2) st2.makingOffer = false; }
      }
    }catch(e){}
  }

  // ---- UI ----
  enterBtn.addEventListener('click', async ()=>{ myName=(nameInput.value||'').trim()||'Anon'; try{ await ensureLocalStream(); localMonitor.srcObject=localStream; setMic(true); await initTTS(); } catch(e){ loginStatus.textContent='No se pudo acceder al micrófono: '+e; return; } loginCard.style.display='none'; roomCard.style.display='block'; joined=true; connectWS(); });
  muteBtn.addEventListener('click', ()=>setMic(!micEnabled));
  leaveBtn.addEventListener('click', async ()=>{ joined=false; try{ ws && ws.close(); }catch(_){ } stopPing(); if (wsRetryTimer){ clearInterval(wsRetryTimer); wsRetryTimer=null; } await disableWakeLock(); motoOverlay.style.display='none'; closeAll(); if(localStream) localStream.getTracks().forEach(t=>t.stop()); localStream=null; streams.clear(); pcMap.clear(); peerNames.clear(); roomCard.style.display='none'; loginCard.style.display='block'; });

  motoBtn.addEventListener('click', async ()=>{ if (motoOverlay.style.display==='flex'){ await disableWakeLock(); motoOverlay.style.display='none'; motoBtn.textContent='Modo Moto: OFF'; return; } await enableWakeLock(); motoOverlay.style.display='flex'; motoBtn.textContent='Modo Moto: ON'; try{ if (!ttsReady) await initTTS(); }catch(_){ } });
  overlayExit.addEventListener('click', async ()=>{ await disableWakeLock(); motoOverlay.style.display='none'; motoBtn.textContent='Modo Moto: OFF'; });
  overlayMute.addEventListener('click', ()=>setMic(!micEnabled));
  window.addEventListener('online', ()=>{ if(joined && !wsConnected) connectWS(); });
  document.addEventListener('visibilitychange', async ()=>{ if(document.visibilityState==='visible' && joined){ await refreshMicAndRenegotiate(); if (motoOverlay.style.display==='flex' && !wakeLock) await enableWakeLock(); } });
})();
</script>

<script type="module" src="/js/native-mic.bootstrap.js"></script>
</body>
</html>
