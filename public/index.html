<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>WebTalk</title>
  <style>
    :root { color-scheme: dark light; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; line-height: 1.35; }
    .wrap { max-width: 900px; margin: 0 auto; }
    .card { border: 1px solid #9993; border-radius: 16px; padding: 16px; margin: 0 auto 16px auto; }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    input, button, select { padding: 10px; border-radius: 10px; border: 1px solid #8886; background: transparent; color: inherit; }
    button { cursor: pointer; }
    .status { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; white-space: pre-wrap; margin-top: 8px; opacity: .9; }
    .dim { opacity: .7; font-weight: 400; }
    .ok { color: #1b8f1b; }
    .err { color: #c72424; }
    .sep { height: 1px; background: #9993; margin: 12px 0; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; }
    .pill { padding: 6px 10px; border-radius: 999px; border: 1px dashed #8886; font-size: 12px; }
    .hidden { display: none !important; }

    /* Lista de usuarios */
    #userList { list-style: none; padding: 0; margin: 0; }
    #userList li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid #9993;
      padding: 4px 6px;
      font-size: 14px;
    }
    #userList li span.name { flex: 1; }

    /* Audios remotos */
    #audios { display: grid; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); gap: 8px; }
    .peer-audio { border: 1px dashed #8886; border-radius: 10px; padding: 8px; }
    .peer-audio h5 { margin: 0 0 6px 0; font-size: 13px; opacity: .8; }
    .peer-audio audio { width: 100%; display: block; }
  </style>
</head>
<body>
<div class="wrap">

  <!-- LOGIN -->
  <div class="card" id="loginCard">
    <h2>WebTalk</h2>
    <p>Introduce <b>nombre</b>, <b>sala</b> y <b>clave</b>. Todos los usuarios con la misma sala y clave se comunican entre sÃ­.</p>
    <div class="row">
      <input id="nameInput" placeholder="Tu nombre" maxlength="64"/>
    </div>
    <div class="row">
      <input id="roomInput" placeholder="Nombre de la sala" maxlength="64"/>
      <input id="keyInput" placeholder="Clave" maxlength="64" type="password"/>
      <button id="enterBtn">Entrar</button>
    </div>
    <div class="row">
      <label class="pill"><input type="checkbox" id="turnOnlyChk"> Usar TURN sÃ³lo</label>
    </div>
    <div class="status" id="loginStatus"></div>
  </div>

  <!-- SALA -->
  <div class="card hidden" id="roomCard">
    <h3><span id="roomTitle"></span> <span class="dim">(mic siempre abierto)</span></h3>
    <div class="controls">
      <button id="leaveBtn">Salir</button>
      <button id="muteBtn">Silenciar mic</button>
      <span class="pill" id="iceState">ICE: NEW</span>
    </div>

    <div class="sep"></div>

    <h4>Usuarios en la sala</h4>
    <ul id="userList"></ul>

    <div class="sep"></div>
    <h4>Audio de participantes</h4>
    <div id="audios"></div>

    <div class="status" id="callStatus"></div>
  </div>

</div>

<script>
(() => {
  const $ = s => document.querySelector(s);

  const loginCard = $('#loginCard');
  const roomCard = $('#roomCard');
  const nameInput = $('#nameInput');
  const roomInput = $('#roomInput');
  const keyInput   = $('#keyInput');
  const enterBtn  = $('#enterBtn');
  const leaveBtn  = $('#leaveBtn');
  const muteBtn   = $('#muteBtn');
  const turnOnlyChk = $('#turnOnlyChk');
  const roomTitle = $('#roomTitle');
  const loginStatus = $('#loginStatus');
  const callStatus  = $('#callStatus');
  const iceStateEl = $('#iceState');
  const userList = $('#userList');
  const audiosWrap = $('#audios');

  let ws, myId, myName, myRoom, myKey;
  let localStream = null;
  let muted = false;

  // --- NUEVO: ReconexiÃ³n automÃ¡tica ---
  let reconnectTimer = null;
  function scheduleReconnect() {
    if (reconnectTimer) return;
    L.ws("Intentando reconectar WebSocket...");
    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connectWS();
    }, 3000); // reintenta cada 3 segundos
  }

  // Estado multipunto
  const peers = new Map(); // peerId -> { pc, audioEl, polite, makingOffer, pendingCandidates:[] }
  const users = {};        // clientId -> {name, muted}

  // --- TTS / estado ---
  function speak(text) {
    try { const msg = new SpeechSynthesisUtterance(text); msg.lang = "es-ES"; speechSynthesis.speak(msg); } catch {}
  }
  const L = {
    login: (msg, cls='') => { console.log('[LOGIN]', msg); loginStatus.textContent = msg; loginStatus.className = `status ${cls}`; },
    call:  (msg, cls='') => { console.log('[CALL]', msg);  callStatus.textContent  = msg;  callStatus.className  = `status ${cls}`; },
    ws:    (...a) => console.log('[WS]', ...a),
    rtc:   (...a) => console.log('[RTC]', ...a),
    ice:   (...a) => console.log('[ICE]', ...a),
    err:   (...a) => console.error('[ERR]', ...a),
  };

  // UI helpers
  function showRoomUI(on) {
    loginCard.classList.toggle('hidden', on);
    roomCard.classList.toggle('hidden', !on);
  }
  function renderUserList() {
    userList.innerHTML = "";
    Object.entries(users).forEach(([id, info]) => {
      const li = document.createElement("li");
      const mic = info.muted ? "ðŸ”´" : "ðŸŸ¢";
      const me = id === myId ? " (yo)" : "";
      li.innerHTML = `<span class="name">${mic} ${info.name}${me}</span>`;
      userList.appendChild(li);
    });
  }
  function addUser(id, name, isMuted=false) { users[id] = {name, muted:isMuted}; renderUserList(); }
  function removeUser(id) { delete users[id]; renderUserList(); }
  function updateUserMute(id, m) { if (users[id]) users[id].muted = m; renderUserList(); }

  // --- Media ---
  async function ensureLocalStream() {
    if (localStream && localStream.getTracks().length) return localStream;
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    setMicMuted(false);
    return localStream;
  }
  function setMicMuted(m) {
    muted = m;
    if (localStream) localStream.getAudioTracks().forEach(t => t.enabled = !m);
    muteBtn.textContent = m ? 'Activar mic' : 'Silenciar mic';
    ws && ws.readyState === 1 && ws.send(JSON.stringify({ type: "mute-changed", muted }));
    updateUserMute(myId, m);
  }

  // ICE servers
  function buildIceServers(turnOnly=false){
    const ours = [
      { urls: 'turn:cachofotos.ddns.net:3478?transport=udp', username: 'djcacho', credential: '4+ymh5XaTXzAVkUB' },
      { urls: 'turn:cachofotos.ddns.net:3478?transport=tcp', username: 'djcacho', credential: '4+ymh5XaTXzAVkUB' },
      { urls: 'turns:cachofotos.ddns.net:5349', username: 'djcacho', credential: '4+ymh5XaTXzAVkUB' }
    ];
    const stun = [{ urls: 'stun:stun.l.google.com:19302' }];
    return turnOnly ? ours : [...stun, ...ours];
  }

  // Rol "polite": usamos una polÃ­tica determinista por id
  function isPoliteAgainst(remoteId) {
    if (!myId || !remoteId) return true;
    return String(myId).localeCompare(String(remoteId)) < 0;
  }

  // Crear (o recuperar) una sesiÃ³n PC por peer
  function ensurePeer(peerId, label='Usuario') {
    if (peers.has(peerId)) return peers.get(peerId);

    const pc = new RTCPeerConnection({ iceServers: buildIceServers(turnOnlyChk.checked), sdpSemantics: 'unified-plan' });

    // Estado ICE de ese PC (mostramos el "Ãºltimo" estado observado)
    pc.oniceconnectionstatechange = () => {
      const state = pc.iceConnectionState;
      iceStateEl.textContent = `ICE: ${state}`;
      if (state === "disconnected" || state === "failed") {
        L.ice(`Reconectando con ${peerId}...`);
        dropPeer(peerId);
        ensureLocalStream().then(async () => {
          const repaired = ensurePeer(peerId, users[peerId]?.name || "Usuario");
          if (!repaired.polite) await maybeCall(peerId);
        });
      }
    };

    // ReenvÃ­o de ICE al destinatario correcto
    pc.onicecandidate = ev => {
      if (ev.candidate) {
        ws && ws.send(JSON.stringify({
          type:'signal',
          targetId: peerId,
          payload:{ candidate: ev.candidate }
        }));
      }
    };

    // Audio remoto â†’ un <audio> por peer
    const card = document.createElement('div');
    card.className = 'peer-audio';
    const title = document.createElement('h5');
    title.textContent = `ðŸŽ§ ${users[peerId]?.name || label} (${peerId.slice(0,8)})`;
    const audio = document.createElement('audio');
    audio.autoplay = true; audio.playsInline = true; audio.controls = true;
    card.appendChild(title); card.appendChild(audio);
    audiosWrap.appendChild(card);

    pc.ontrack = ev => {
      audio.srcObject = ev.streams?.[0] || new MediaStream([ev.track]);
    };

    const sess = {
      pc,
      audioEl: audio,
      cardEl: card,
      polite: isPoliteAgainst(peerId),
      makingOffer: false,
      pendingCandidates: []
    };

    if (localStream) {
      const have = pc.getSenders().map(s => s.track);
      localStream.getAudioTracks().forEach(t => {
        if (!have.includes(t)) pc.addTrack(t, localStream);
      });
    }

    peers.set(peerId, sess);
    return sess;
  }

  // Eliminar peer
  function dropPeer(peerId) {
    const sess = peers.get(peerId);
    if (!sess) return;
    try { sess.pc.close(); } catch {}
    if (sess.cardEl?.parentNode) sess.cardEl.parentNode.removeChild(sess.cardEl);
    peers.delete(peerId);
  }

  // Iniciar oferta (caller) hacia un peer
  async function maybeCall(peerId) {
    const sess = peers.get(peerId);
    if (!sess) return;
    const { pc } = sess;
    try {
      sess.makingOffer = true;
      const offer = await pc.createOffer({ offerToReceiveAudio: true });
      await pc.setLocalDescription(offer);
      ws && ws.send(JSON.stringify({
        type:'signal',
        targetId: peerId,
        payload:{ sdp:{ type:'offer', sdp: offer.sdp } }
      }));
    } catch (e) {
      L.err('createOffer/setLocalDescription error', e);
    } finally {
      sess.makingOffer = false;
    }
  }

  // SeÃ±alizaciÃ³n entrante
  async function handleSignalFrom(fromId, payload) {
    const sess = ensurePeer(fromId);
    const { pc } = sess;

    if (payload.sdp) {
      const { type, sdp } = payload.sdp;
      const isOffer = type === 'offer';
      const offerCollision = isOffer && (sess.makingOffer || pc.signalingState !== 'stable');

      if (offerCollision) {
        if (!sess.polite) {
          L.rtc(`âš ï¸ ColisiÃ³n de oferta con ${fromId}: impolite â†’ rehago conexiÃ³n`);
          dropPeer(fromId);
          const repaired = ensurePeer(fromId, users[fromId]?.name || 'Usuario');
          if (localStream) {
            const have = repaired.pc.getSenders().map(s => s.track);
            localStream.getAudioTracks().forEach(t => { if (!have.includes(t)) repaired.pc.addTrack(t, localStream); });
          }
          await maybeCall(fromId);
          return;
        }
        try { await pc.setLocalDescription({ type: 'rollback' }); } catch {}
      }

      if (isOffer) {
        await pc.setRemoteDescription({ type:'offer', sdp });
        if (localStream) {
          const have = pc.getSenders().map(s => s.track);
          localStream.getAudioTracks().forEach(t => {
            if (!have.includes(t)) pc.addTrack(t, localStream);
          });
        }
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws && ws.send(JSON.stringify({
          type:'signal',
          targetId: fromId,
          payload:{ sdp:{ type:'answer', sdp: answer.sdp } }
        }));
        while (sess.pendingCandidates.length) {
          const c = sess.pendingCandidates.shift();
          try { await pc.addIceCandidate(c); } catch {}
        }
        return;
      }

      if (type === 'answer') {
        if (pc.signalingState !== 'have-local-offer') return;
        await pc.setRemoteDescription({ type:'answer', sdp });
        while (sess.pendingCandidates.length) {
          const c = sess.pendingCandidates.shift();
          try { await pc.addIceCandidate(c); } catch {}
        }
        return;
      }
    }

    if (payload.candidate) {
      if (!pc.remoteDescription) {
        sess.pendingCandidates.push(payload.candidate);
      } else {
        try { await pc.addIceCandidate(payload.candidate); } catch {}
      }
    }
  }

  // WebSocket
  function connectWS(){
    const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws';
    ws = new WebSocket(wsUrl);

    ws.onopen = () => {
      ws.send(JSON.stringify({ type:'join', name:myName, room:myRoom, key:myKey }));
    };

    ws.onmessage = async ev => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      switch(msg.type){
        case 'auth-failed':
          L.login(`Clave incorrecta para sala "${myRoom}"`, 'err');
          try { ws.close(); } catch {}
          showRoomUI(false);
          break;

        case 'joined': {
          myId = msg.clientId;
          roomTitle.textContent = `Sala: ${msg.room}`;
          showRoomUI(true);

          audiosWrap.innerHTML = '';
          for (const [pid] of peers) dropPeer(pid);
          Object.keys(users).forEach(k => delete users[k]);

          addUser(myId, myName, muted);
          (msg.peers || []).forEach(p => addUser(p.clientId, p.name, p.muted));
          L.login(`Unido a sala "${msg.room}"`, 'ok');

          await ensureLocalStream();
          for (const p of (msg.peers || [])) {
            const sess = ensurePeer(p.clientId, p.name);
            if (!sess.polite) await maybeCall(p.clientId);
          }
          if (!Array.isArray(msg.peers) || !msg.peers.length) {
            L.call('Sala vacÃ­a. Esperando otros usuariosâ€¦');
          }
          break;
        }

        case 'peer-joined':
          const pid = msg.clientId;
          const pname = msg.name || 'un usuario';
          addUser(pid, pname, msg.muted);
          speak(`${pname} se ha unido a la sala`);
          L.call(`ðŸ‘‹ ${pname} se ha unido`);
          ensureLocalStream().then(async () => {
            const sess = ensurePeer(pid, pname);
            if (!sess.polite) await maybeCall(pid);
          });
          break;

        case 'peer-left':
          const leftId = msg.clientId;
          const leftName = msg.name || 'un usuario';
          speak(`${leftName} ha salido de la sala`);
          L.call(`âŒ ${leftName} saliÃ³`);
          removeUser(leftId);
          dropPeer(leftId);
          break;

        case 'mute-changed':
          updateUserMute(msg.clientId, msg.muted);
          break;

        case 'signal':
          await handleSignalFrom(msg.fromId, msg.payload || {});
          break;
      }
    };

    // --- NUEVO: reconectar si se pierde la conexiÃ³n WS ---
    ws.onclose = () => {
      L.ws("ConexiÃ³n WebSocket cerrada. Intentando reconectar...");
      scheduleReconnect();
    };
    ws.onerror = () => {
      L.ws("Error en WebSocket. Intentando reconectar...");
      scheduleReconnect();
    };

    // --- NUEVO: mantener viva la sesiÃ³n ---
    setInterval(() => {
      if (ws && ws.readyState === 1)
        ws.send(JSON.stringify({ type: "ping" }));
    }, 10000);
  }

  // Entrar / Salir / Mute
  enterBtn.onclick = async () => {
    myName = nameInput.value.trim();
    myRoom = roomInput.value.trim();
    myKey  = keyInput.value.trim();
    if (!myName || !myRoom || !myKey) { L.login('Completa todos los campos','err'); return; }
    await ensureLocalStream();
    setMicMuted(false);
    connectWS();
  };

  leaveBtn.onclick = () => {
    try { ws && ws.close(); } catch {}
    for (const [pid] of peers) dropPeer(pid);
    audiosWrap.innerHTML = '';
    showRoomUI(false);
  };

  muteBtn.onclick = () => setMicMuted(!muted);

  showRoomUI(false);
})();
</script>
</body>
</html>
