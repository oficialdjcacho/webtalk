<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>WebTalk</title>
  <style>
    :root { color-scheme: dark light; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; line-height: 1.35; }
    .wrap { max-width: 900px; margin: 0 auto; }
    .card { border: 1px solid #9993; border-radius: 16px; padding: 16px; margin: 0 auto 16px auto; }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    input, button, select { padding: 10px; border-radius: 10px; border: 1px solid #8886; background: transparent; color: inherit; }
    button { cursor: pointer; }
    .status { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; white-space: pre-wrap; margin-top: 8px; opacity: .9; }
    .dim { opacity: .7; font-weight: 400; }
    .ok { color: #1b8f1b; }
    .err { color: #c72424; }
    .sep { height: 1px; background: #9993; margin: 12px 0; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; }
    .pill { padding: 6px 10px; border-radius: 999px; border: 1px dashed #8886; font-size: 12px; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
<div class="wrap">

  <!-- LOGIN -->
  <div class="card" id="loginCard">
    <h2>WebTalk</h2>
    <p>Introduce <b>nombre</b>, <b>sala</b> y <b>clave</b> y pulsa <b>Entrar</b>. Todos los usuarios con la misma
      sala+clave se comunican entre s√≠; no existe la sala global.</p>
    <div class="row">
      <input id="nameInput" placeholder="Tu nombre" maxlength="64" autocomplete="nickname"/>
    </div>
    <div class="row">
      <input id="roomInput" placeholder="Nombre de la sala" maxlength="64" autocomplete="off"/>
      <input id="keyInput" placeholder="Clave de la sala" maxlength="64" type="password" autocomplete="off"/>
      <button id="enterBtn">Entrar</button>
    </div>
    <div class="row">
      <label class="pill"><input type="checkbox" id="turnOnlyChk"> Usar TURN s√≥lo (depuraci√≥n NAT)</label>
    </div>
    <div class="status" id="loginStatus"></div>
  </div>

  <!-- SALA -->
  <div class="card hidden" id="roomCard">
    <h3><span id="roomTitle">Sala</span> <span class="dim">(mic siempre abierto)</span></h3>
    <div class="controls">
      <button id="leaveBtn">Salir</button>
      <button id="muteBtn">Silenciar mic</button>
      <span class="pill" id="pcState">PC: NEW</span>
      <span class="pill" id="iceState">ICE: NEW</span>
    </div>
    <div class="sep"></div>
    <div class="row">
      <audio id="remoteAudio" autoplay playsinline></audio>
    </div>
    <div class="status" id="callStatus"></div>
  </div>

</div>

<script>
(function(){
  // ---------- Utilidad ----------
  const $ = (sel) => document.querySelector(sel);
  const logLogin = (msg, cls='') => { loginStatus.textContent = msg; loginStatus.className = `status ${cls}`; };
  const logCall  = (msg, cls='') => { callStatus.textContent  = msg; callStatus.className  = `status ${cls}`; };

  // ---------- Elementos ----------
  const loginCard    = $('#loginCard');
  const roomCard     = $('#roomCard');
  const nameInput    = $('#nameInput');
  const roomInput    = $('#roomInput');
  const keyInput     = $('#keyInput');
  const enterBtn     = $('#enterBtn');
  const leaveBtn     = $('#leaveBtn');
  const muteBtn      = $('#muteBtn');
  const turnOnlyChk  = $('#turnOnlyChk');
  const roomTitle    = $('#roomTitle');
  const loginStatus  = $('#loginStatus');
  const callStatus   = $('#callStatus');
  const pcStateEl    = $('#pcState');
  const iceStateEl   = $('#iceState');
  const remoteAudio  = $('#remoteAudio');

  // ---------- Estado ----------
  let ws = null;
  let myId = null;
  let remoteId = null;
  let myName = '';
  let myRoom = '';
  let myKey  = '';
  let pc = null;
  let localStream = null;
  let muted = false;

  // ---------- ICE servers ----------
  function buildIceServers(turnOnly=false){
    const base = [
      { urls: 'stun:stun.l.google.com:19302' }
    ];
    const ours = [
      { urls: 'turn:cachofotos.ddns.net:3478?transport=udp', username: 'djcacho', credential: '4+ymh5XaTXzAVkUB' },
      { urls: 'turn:cachofotos.ddns.net:3478?transport=tcp', username: 'djcacho', credential: '4+ymh5XaTXzAVkUB' },
      { urls: 'turns:cachofotos.ddns.net:5349',               username: 'djcacho', credential: '4+ymh5XaTXzAVkUB' }
    ];
    return turnOnly ? ours : [...base, ...ours];
  }

  // ---------- UI helpers ----------
  function showRoomUI(on){
    loginCard.classList.toggle('hidden', on);
    roomCard.classList.toggle('hidden', !on);
  }

  function updatePCState(){
    if (!pc) { pcStateEl.textContent = 'PC: CLOSED'; return; }
    pcStateEl.textContent = 'PC: ' + pc.connectionState.toUpperCase();
    iceStateEl.textContent = 'ICE: ' + pc.iceConnectionState.toUpperCase();
  }

  function setMicMuted(m){
    muted = m;
    if (localStream){
      localStream.getAudioTracks().forEach(t => t.enabled = !m);
    }
    muteBtn.textContent = m ? 'Activar mic' : 'Silenciar mic';
  }

  // ---------- WebSocket ----------
  function connectWS(){
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)){
      try { ws.close(); } catch(e){}
    }
    // auto: usar mismo host con wss si la p√°gina est√° en https. Si sirves est√°tico detr√°s de tu dominio, esto seguir√° funcionando.
    const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws';
    ws = new WebSocket(wsUrl);

    ws.onopen = () => {
      logLogin('Conectado a se√±alizaci√≥n. Autenticando‚Ä¶');
      const msg = { type: 'join', name: myName, room: myRoom, key: myKey };
      ws.send(JSON.stringify(msg));
    };

    ws.onclose = () => {
      logCall('Se√±alizaci√≥n desconectada.', 'err');
    };

    ws.onerror = (ev) => {
      logLogin('Error de WebSocket.', 'err');
      console.error('WS error', ev);
    };

    ws.onmessage = (ev) => {
      let data;
      try{ data = JSON.parse(ev.data); } catch(e){ console.warn('WS parse', e); return; }

      switch(data.type){
        case 'auth-failed':
          // el server responde con {type:'auth-failed', reason:'...'}
          logLogin(`Clave incorrecta para sala "${myRoom}".`, 'err');
          try { ws.close(); } catch(e){}
          teardownPC(true);
          showRoomUI(false);
          break;

        case 'joined':
          // {type:'joined', clientId, peers:[{clientId,name}], room}
          myId = data.clientId;
          logLogin(`Acceso concedido a sala "${data.room}".`, 'ok');
          roomTitle.textContent = `Sala: ${data.room}`;
          showRoomUI(true);
          // Si ya hay alguien, elegimos el primero y ofrecemos
          if (Array.isArray(data.peers) && data.peers.length > 0){
            remoteId = data.peers[0].clientId;
            startCall(/*isCaller*/true);
          } else {
            logCall('Sala vac√≠a. Esperando a otro usuario‚Ä¶');
          }
          break;

        case 'peer-joined':
          // {type:'peer-joined', clientId, name}
          if (!remoteId){
            remoteId = data.clientId;
            startCall(true);
          } else {
            logCall(`Otro peer se uni√≥ (${data.clientId}), ya estamos conectados con uno.`);
          }
          break;

        case 'peer-left':
          if (remoteId && data.clientId === remoteId){
            logCall('El peer remoto sali√≥. Conexi√≥n cerrada.');
            remoteId = null;
            teardownPC(false);
          }
          break;

        case 'signal':
          handleSignalFromPeer(data);
          break;
      }
    };
  }

  function sendToPeer(payload){
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    if (!remoteId) return;
    ws.send(JSON.stringify({ type: 'signal', targetId: remoteId, payload }));
  }

  // ---------- WebRTC ----------
  async function ensureLocalStream(){
    if (localStream) return localStream;
    // iOS/Android requieren interacci√≥n previa del usuario (el bot√≥n Entrar ya lo cumple)
    localStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true }, video: false });
    return localStream;
  }

  function createPC(){
    if (pc) return pc;
    pc = new RTCPeerConnection({ iceServers: buildIceServers(turnOnlyChk.checked), sdpSemantics: 'unified-plan' });

    pc.onconnectionstatechange = updatePCState;
    pc.oniceconnectionstatechange = updatePCState;

    pc.onicecandidate = (ev) => {
      if (ev.candidate){
        sendToPeer({ candidate: {
          candidate: ev.candidate.candidate,
          sdpMid: ev.candidate.sdpMid,
          sdpMLineIndex: ev.candidate.sdpMLineIndex
        }});
      }
    };

    pc.ontrack = (ev) => {
      // S√≥lo audio
      if (ev.streams && ev.streams[0]) {
        remoteAudio.srcObject = ev.streams[0];
      } else {
        // Fallback: construir stream manual a partir de tracks
        const ms = new MediaStream();
        ms.addTrack(ev.track);
        remoteAudio.srcObject = ms;
      }
      logCall('üîä Audio remoto recibido.');
    };

    updatePCState();
    return pc;
  }

  async function startCall(isCaller){
    await ensureLocalStream();
    const pc = createPC();
    // A√±adimos track local
    localStream.getAudioTracks().forEach(t => pc.addTrack(t, localStream));

    if (isCaller){
      const offer = await pc.createOffer({ offerToReceiveAudio: true });
      await pc.setLocalDescription(offer);
      sendToPeer({ sdp: { type: 'offer', sdp: offer.sdp }});
      logCall('üì§ Oferta enviada.');
    } else {
      logCall('Esperando oferta del remoto‚Ä¶');
    }
  }

  async function handleSignalFromPeer(msg){
    const { fromId, payload } = msg;
    if (!remoteId) remoteId = fromId || remoteId;

    const pc = createPC();

    // SDP
    if (payload && payload.sdp){
      const { type, sdp } = payload.sdp;
      if (type === 'offer'){
        await ensureLocalStream();
        localStream.getAudioTracks().forEach(t => pc.addTrack(t, localStream));
        await pc.setRemoteDescription({ type: 'offer', sdp });
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        sendToPeer({ sdp: { type: 'answer', sdp: answer.sdp }});
        logCall('üì° Respuesta enviada.');
        return;
      }
      if (type === 'answer'){
        await pc.setRemoteDescription({ type: 'answer', sdp });
        logCall('üì• Respuesta establecida.');
        return;
      }
    }

    // ICE
    if (payload && payload.candidate){
      const c = payload.candidate;
      try{
        await pc.addIceCandidate(new RTCIceCandidate(c));
      }catch(e){
        console.error('Error addIceCandidate', e);
      }
    }
  }

  function teardownPC(resetStream){
    if (pc){
      try { pc.getSenders().forEach(s => { try{ pc.removeTrack(s);}catch(_){}});} catch(_){}
      try { pc.close(); } catch(_){}
    }
    pc = null;
    updatePCState();

    if (resetStream && localStream){
      try { localStream.getTracks().forEach(t => t.stop()); } catch(_){}
      localStream = null;
    }
    remoteAudio.srcObject = null;
  }

  // ---------- Eventos UI ----------
  enterBtn.addEventListener('click', async () => {
    myName = (nameInput.value || '').trim();
    myRoom = (roomInput.value || '').trim();
    myKey  = (keyInput.value  || '').trim();

    if (!myName){ logLogin('Introduce tu nombre.', 'err'); nameInput.focus(); return; }
    if (!myRoom){ logLogin('Introduce el nombre de la sala.', 'err'); roomInput.focus(); return; }
    if (!myKey){  logLogin('Introduce la clave de la sala.', 'err'); keyInput.focus(); return; }

    logLogin('Solicitando permisos de micr√≥fono‚Ä¶');
    try{
      await ensureLocalStream();
      setMicMuted(false);
      logLogin('Permisos concedidos. Conectando‚Ä¶');
      connectWS();
    }catch(e){
      console.error(e);
      logLogin('No se pudo acceder al micr√≥fono.', 'err');
    }
  });

  leaveBtn.addEventListener('click', () => {
    try{ ws && ws.close(); }catch(_){}
    remoteId = null;
    teardownPC(true);
    showRoomUI(false);
    logLogin('Has salido de la sala.');
  });

  muteBtn.addEventListener('click', () => setMicMuted(!muted));

  // --------- Inicio ----------
  showRoomUI(false);
  updatePCState();
})();
</script>
</body>
</html>
