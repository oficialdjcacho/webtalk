<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>WebTalk</title>
  <style>
    :root { color-scheme: dark light; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; line-height: 1.35; }
    .wrap { max-width: 900px; margin: 0 auto; }
    .card { border: 1px solid #9993; border-radius: 16px; padding: 16px; margin: 0 auto 16px auto; }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    input, button, select { padding: 10px; border-radius: 10px; border: 1px solid #8886; background: transparent; color: inherit; }
    button { cursor: pointer; }
    .status { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; white-space: pre-wrap; margin-top: 8px; opacity: .9; }
    .dim { opacity: .7; font-weight: 400; }
    .ok { color: #1b8f1b; }
    .err { color: #c72424; }
    .sep { height: 1px; background: #9993; margin: 12px 0; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; }
    .pill { padding: 6px 10px; border-radius: 999px; border: 1px dashed #8886; font-size: 12px; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
<div class="wrap">

  <!-- LOGIN -->
  <div class="card" id="loginCard">
    <h2>WebTalk</h2>
    <p>Introduce <b>nombre</b>, <b>sala</b> y <b>clave</b>. Todos los usuarios con la misma sala y clave se comunican entre s√≠.</p>
    <div class="row">
      <input id="nameInput" placeholder="Tu nombre" maxlength="64"/>
    </div>
    <div class="row">
      <input id="roomInput" placeholder="Nombre de la sala" maxlength="64"/>
      <input id="keyInput" placeholder="Clave" maxlength="64" type="password"/>
      <button id="enterBtn">Entrar</button>
    </div>
    <div class="row">
      <label class="pill"><input type="checkbox" id="turnOnlyChk"> Usar TURN s√≥lo</label>
    </div>
    <div class="status" id="loginStatus"></div>
  </div>

  <!-- SALA -->
  <div class="card hidden" id="roomCard">
    <h3><span id="roomTitle"></span> <span class="dim">(mic siempre abierto)</span></h3>
    <div class="controls">
      <button id="leaveBtn">Salir</button>
      <button id="muteBtn">Silenciar mic</button>
      <span class="pill" id="pcState">PC: NEW</span>
      <span class="pill" id="iceState">ICE: NEW</span>
    </div>
    <div class="sep"></div>
    <div class="row">
      <audio id="remoteAudio" autoplay playsinline></audio>
    </div>
    <div class="status" id="callStatus"></div>
  </div>

</div>

<script>
(() => {
  const $ = s => document.querySelector(s);

  const loginCard = $('#loginCard');
  const roomCard = $('#roomCard');
  const nameInput = $('#nameInput');
  const roomInput = $('#roomInput');
  const keyInput   = $('#keyInput');
  const enterBtn  = $('#enterBtn');
  const leaveBtn  = $('#leaveBtn');
  const muteBtn   = $('#muteBtn');
  const turnOnlyChk = $('#turnOnlyChk');
  const roomTitle = $('#roomTitle');
  const loginStatus = $('#loginStatus');
  const callStatus  = $('#callStatus');
  const pcStateEl = $('#pcState');
  const iceStateEl = $('#iceState');
  const remoteAudio = $('#remoteAudio');

  let ws, myId, remoteId, myName, myRoom, myKey;
  let pc = null;
  let localStream = null;
  let muted = false;

  // Perfect Negotiation
  let makingOffer = false;
  let ignoreOffer = false;
  let polite = false; // se decide al fijar remoteId
  
  // Cola de ICE hasta tener remoteDescription
  const pendingCandidates = [];

  // LOG helpers
  const L = {
    login: (msg, cls='') => { console.log('[LOGIN]', msg); loginStatus.textContent = msg; loginStatus.className = `status ${cls}`; },
    call:  (msg, cls='') => { console.log('[CALL]', msg);  callStatus.textContent  = msg;  callStatus.className  = `status ${cls}`; },
    ws:    (...a) => console.log('[WS]', ...a),
    rtc:   (...a) => console.log('[RTC]', ...a),
    ice:   (...a) => console.log('[ICE]', ...a),
    err:   (...a) => console.error('[ERR]', ...a),
    warn:  (...a) => console.warn('[WARN]', ...a),
    dbg:   (...a) => console.debug('[DBG]', ...a),
  };

  function showRoomUI(on) {
    loginCard.classList.toggle('hidden', on);
    roomCard.classList.toggle('hidden', !on);
  }

  function updatePCState() {
    if (!pc) { pcStateEl.textContent = 'PC: CLOSED'; iceStateEl.textContent = 'ICE: CLOSED'; return; }
    pcStateEl.textContent = `PC: ${pc.connectionState}`;
    iceStateEl.textContent = `ICE: ${pc.iceConnectionState}`;
    L.rtc('PC state:', pc.connectionState, 'ICE state:', pc.iceConnectionState, 'signaling:', pc.signalingState);
  }

  function buildIceServers(turnOnly=false){
    const ours = [
      { urls: 'turn:cachofotos.ddns.net:3478?transport=udp', username: 'djcacho', credential: '4+ymh5XaTXzAVkUB' },
      { urls: 'turn:cachofotos.ddns.net:3478?transport=tcp', username: 'djcacho', credential: '4+ymh5XaTXzAVkUB' },
      { urls: 'turns:cachofotos.ddns.net:5349', username: 'djcacho', credential: '4+ymh5XaTXzAVkUB' }
    ];
    const stun = [{ urls: 'stun:stun.l.google.com:19302' }];
    const res = turnOnly ? ours : [...stun, ...ours];
    L.dbg('ICE servers:', res);
    return res;
  }

  async function ensureLocalStream() {
    if (localStream && localStream.getTracks().length) return localStream;
    L.dbg('Solicitando getUserMedia‚Ä¶');
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    L.dbg('getUserMedia OK. Tracks:', localStream.getTracks().map(t => t.kind));
    return localStream;
  }

  function setMicMuted(m) {
    muted = m;
    if (localStream) localStream.getAudioTracks().forEach(t => t.enabled = !m);
    muteBtn.textContent = m ? 'Activar mic' : 'Silenciar mic';
    L.call(m ? 'Mic desactivado' : 'Mic activado');
  }

  function decidePoliteRole() {
    if (!myId || !remoteId) return;
    // Regla determinista: el menor lexicogr√°ficamente es "polite"
    polite = String(myId).localeCompare(String(remoteId)) < 0;
    L.dbg('Roles:', { myId, remoteId, polite });
  }

  function createPC() {
    if (pc) return pc;
    L.dbg('Creando RTCPeerConnection‚Ä¶');
    pc = new RTCPeerConnection({ iceServers: buildIceServers(turnOnlyChk.checked), sdpSemantics: 'unified-plan' });

    pc.onconnectionstatechange = () => {
      updatePCState();
      if (pc.connectionState === 'failed') L.warn('PC failed');
    };
    pc.oniceconnectionstatechange = updatePCState;

    pc.onicecandidate = ev => {
      if (ev.candidate && ws && remoteId) {
        L.ice('Enviando candidate:', ev.candidate);
        ws.send(JSON.stringify({ type:'signal', targetId: remoteId, payload:{ candidate: ev.candidate } }));
      }
    };

    pc.ontrack = ev => {
      const stream = ev.streams?.[0] || new MediaStream([ev.track]);
      remoteAudio.srcObject = stream;
      L.call('üîä Audio remoto recibido');
    };

    pc.onsignalingstatechange = () => {
      L.dbg('Signaling state:', pc.signalingState);
    };

    updatePCState();
    return pc;
  }

  function ensureTrackAdded(pc) {
    if (!localStream) return;
    const existingTracks = pc.getSenders().map(s => s.track).filter(Boolean);
    localStream.getAudioTracks().forEach(track => {
      if (!existingTracks.includes(track)) {
        L.dbg('A√±adiendo track local‚Ä¶');
        pc.addTrack(track, localStream);
      } else {
        L.dbg('Track local ya a√±adido, se omite.');
      }
    });
  }

  async function startCallIfCaller() {
    // El lado impolite inicia; el polite espera
    if (!polite && remoteId) {
      const pc = createPC();
      ensureTrackAdded(pc);
      try {
        makingOffer = true;
        const offer = await pc.createOffer({ offerToReceiveAudio: true });
        await pc.setLocalDescription(offer);
        L.rtc('üì§ Oferta enviada');
        ws.send(JSON.stringify({ type:'signal', targetId: remoteId, payload:{ sdp:{ type:'offer', sdp:offer.sdp } } }));
      } catch (e) {
        L.err('Error creando/enviando offer:', e);
      } finally {
        makingOffer = false;
      }
    } else {
      L.dbg('Soy polite o no hay remoteId: no inicio llamada');
    }
  }

  async function applyPendingCandidates() {
    if (!pc || !pc.remoteDescription) return;
    if (!pendingCandidates.length) return;
    L.ice(`Aplicando ${pendingCandidates.length} ICE candidates en cola‚Ä¶`);
    while (pendingCandidates.length) {
      const c = pendingCandidates.shift();
      try {
        await pc.addIceCandidate(c);
      } catch (e) {
        L.warn('addIceCandidate fallo (cola):', e);
      }
    }
  }

  async function handleSignal(msg) {
    const { fromId, payload } = msg;
    if (!remoteId) {
      remoteId = fromId;
      decidePoliteRole();
    }
    const pc = createPC();

    if (payload.sdp) {
      const { type, sdp } = payload.sdp;
      L.ws('SDP recibido:', type, ' estado actual:', pc.signalingState, 'makingOffer:', makingOffer, 'polite:', polite);

      const isOffer = type === 'offer';
      const offerCollision = isOffer && (makingOffer || pc.signalingState !== 'stable');

      if (offerCollision) {
        if (!polite) {
          L.warn('‚ö†Ô∏è Oferta simult√°nea detectada. Soy impolite ‚Üí ignoro.');
          return; // impolite ignora glare
        }
        // polite hace rollback y acepta la oferta
        L.warn('‚ö†Ô∏è Oferta simult√°nea detectada. Soy polite ‚Üí rollback y acepto oferta.');
        try {
          await Promise.allSettled([
            pc.setLocalDescription({ type: 'rollback' }),
            pc.setRemoteDescription({ type: 'offer', sdp })
          ]);
        } catch (e) {
          L.err('Fallo en rollback/remoteDescription:', e);
          return;
        }
        try {
          ensureTrackAdded(pc);
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({ type:'signal', targetId: remoteId, payload:{ sdp:{ type:'answer', sdp:answer.sdp } } }));
          L.rtc('üì° Respuesta enviada (tras rollback)');
          await applyPendingCandidates();
        } catch (e) {
          L.err('Error creando/enviando answer (tras rollback):', e);
        }
        return;
      }

      if (isOffer) {
        try {
          await pc.setRemoteDescription({ type:'offer', sdp });
          L.rtc('üì• Oferta establecida');
          ensureTrackAdded(pc);
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({ type:'signal', targetId: remoteId, payload:{ sdp:{ type:'answer', sdp:answer.sdp } } }));
          L.rtc('üì° Respuesta enviada');
          await applyPendingCandidates();
        } catch (e) {
          L.err('Error manejando offer:', e);
        }
        return;
      }

      if (type === 'answer') {
        if (pc.signalingState !== 'have-local-offer') {
          L.warn('‚ö†Ô∏è Answer fuera de sincronizaci√≥n. signaling=', pc.signalingState);
          return;
        }
        try {
          await pc.setRemoteDescription({ type:'answer', sdp });
          L.rtc('üì• Respuesta establecida');
          await applyPendingCandidates();
        } catch (e) {
          L.err('Error fijando answer:', e);
        }
        return;
      }
    }

    if (payload.candidate) {
      if (!pc.remoteDescription) {
        L.ice('ICE recibido sin remoteDescription a√∫n ‚Üí en cola.');
        pendingCandidates.push(payload.candidate);
      } else {
        try {
          await pc.addIceCandidate(payload.candidate);
          L.ice('ICE a√±adido inmediatamente');
        } catch (e) {
          L.warn('addIceCandidate error (inmediato):', e);
        }
      }
    }
  }

  function teardownPC(stopTracks){
    if (pc) {
      try { pc.ontrack = null; pc.onicecandidate = null; pc.onconnectionstatechange = null; pc.oniceconnectionstatechange = null; } catch {}
      try { pc.close(); } catch {}
    }
    pc = null;
    pendingCandidates.length = 0;
    if (stopTracks && localStream) {
      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
    }
    remoteAudio.srcObject = null;
    makingOffer = false;
    ignoreOffer = false;
    polite = false;
    updatePCState();
  }

  function connectWS(){
    const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws';
    L.ws('Conectando WS a', wsUrl);
    ws = new WebSocket(wsUrl);

    ws.onopen = () => {
      L.ws('Abierto. Enviando join‚Ä¶');
      ws.send(JSON.stringify({ type:'join', name:myName, room:myRoom, key:myKey }));
    };

    ws.onmessage = async ev => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      switch(msg.type){
        case 'auth-failed':
          L.ws('Auth failed');
          L.login(`Clave incorrecta para sala "${myRoom}"`, 'err');
          try { ws.close(); } catch {}
          teardownPC(true);
          showRoomUI(false);
          break;
        case 'joined':
          myId = msg.clientId;
          roomTitle.textContent = `Sala: ${msg.room}`;
          showRoomUI(true);
          L.login(`Unido a sala "${msg.room}"`, 'ok');
          if (Array.isArray(msg.peers) && msg.peers.length) {
            remoteId = msg.peers[0].clientId;
            decidePoliteRole();
            await ensureLocalStream();
            setMicMuted(false);
            startCallIfCaller();
          } else {
            L.call('Sala vac√≠a. Esperando otro usuario‚Ä¶');
          }
          break;
        case 'peer-joined':
          L.ws('peer-joined', msg);
          if (!remoteId) {
            remoteId = msg.clientId;
            decidePoliteRole();
            await ensureLocalStream();
            setMicMuted(false);
            startCallIfCaller();
          } else {
            L.call(`Nuevo peer: ${msg.clientId}`);
          }
          break;
        case 'peer-left':
          L.ws('peer-left', msg);
          if (msg.clientId === remoteId) {
            L.call('El peer remoto sali√≥');
            remoteId = null;
            teardownPC(false);
          }
          break;
        case 'signal':
          await handleSignal(msg);
          break;
        default:
          L.ws('Mensaje no manejado:', msg);
      }
    };

    ws.onclose = () => L.call('Conexi√≥n WS cerrada','err');
    ws.onerror = (e) => L.err('WS error', e);
  }

  // ---- Eventos UI ----
  enterBtn.onclick = async () => {
    myName = nameInput.value.trim();
    myRoom = roomInput.value.trim();
    myKey  = keyInput.value.trim();
    if (!myName || !myRoom || !myKey) {
      L.login('Completa todos los campos','err'); return;
    }
    try {
      await ensureLocalStream(); // pedimos permiso ya
      setMicMuted(false);
      connectWS();
    } catch (e) {
      L.login('No se pudo acceder al micr√≥fono','err');
      L.err(e);
    }
  };

  leaveBtn.onclick = () => {
    try { ws && ws.close(); } catch {}
    remoteId = null;
    teardownPC(true);
    showRoomUI(false);
  };

  muteBtn.onclick = () => setMicMuted(!muted);

  showRoomUI(false);
  updatePCState();
})();
</script>
</body>
</html>
